# study-up

# TCP
## 连接状态详解

CLOSED：初始状态

LISTEN：表示服务器端的某个SOCKET处于监听状态，可以接受连接

SYN_SENT：在服务器端监听后，客户端SOCKET执行CONNECT连接时，客户端发送SYN报文，此时客户端进入SYN_SENT状态，等待服务端的确认

SYN_RCVD：表示服务端接收到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态。

ESTABLISHED：表示连接已经建立

FIN_WAIT1：当SOCKET在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。

FIN_WAIT2：当对方回应ACK报文后，则进入到FIN_WAIT_2状态。

CLOSE_WAIT：表示正在等待关闭。但对方发送FIN报文给自己，你系统会回应一个ACK报文，此时进入CLOSE_WAIT状态。

LAST_ACK：被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。

TIME_WAIT：表示收到了对方的FIN报文，并发出了ACK报文，等2MSL后即可回到CLOSED状态。

## 问题

### 为什么TCP连接的时候是3次

因为要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。

如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。



### 为什么TCP连接的时候是3次，关闭的时候确是4次

因为只有客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发给客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端，我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文（所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来一次）。



### 为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接

这里同样要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL（报文最大生存时间），所以需要等这么长时间来确认服务端确实已经收到了。



### 如果已经建立了连接，但客户端突然出现故障了怎么办

TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若2小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没有反应，服务器就认为客户端出了故障，接着就关闭连接。



### TCP连接大量TIME_WAIT状态问题排查

#### TIME_WAIT产生原因

TIMEWAIT是主动关闭的一方，在使用四次挥手正常关闭TCP连接时产生的。

#### TIME_WAIT状态的必要性

1.确保两端能够完全关闭连接。如果被关闭方没有收到ACK，则会重发FIN，一来一去正好2MSL。

2.确保后续的连接不会收到脏数据。有足够的时间不让当前连接和后面的连接混在一起。

#### 大量TIME_WAIT出现场景

在高并发短连接的TCP服务器上，当服务器处理完请求后立即按照主动正常关闭连接这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端会显示连接不上。

#### 查看TCP连接数

```shell
netstat -ant|awk '/^tcp/ {S++[$NF]} END {for (a in S) print (a,S[a])}'
```

#### 如何尽量处理TIMEWAIT过多

编辑内核文件/etc/sysctl.conf

```shell
net.ipv4.tcp_syncookies = 1 #表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1 #表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 1 #表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
net.ipv4.tcp_fin_timeout #修改系默认的 TIMEOUT 时间
```

然后执行sysctl -p 让参数生效

简单来说，就是打开系统的TIMEWAIT重用和快速回收。

### http状态码
* 1**	信息，服务器收到请求，需要请求者继续执行操作
* 2**	成功，操作被成功接收并处理
* 3**	重定向，需要进一步的操作以完成请求
* 4**	客户端错误，请求包含语法错误或无法完成请求
* 5**	服务器错误，服务器在处理请求的过程中发生了错误

### 301 302
* 301	Moved Permanently	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
* 302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI

### 重传机制
* 超时重传
  * RTO（超时重传时间）略大于RTT（包往返时间）
* 快速重传 
  * 三次相同的ACK触发重传
* SACK 选择确认
  * 将接收数据缓存发送给发送方，告知哪些收到了哪些没收到，只重传没收到的
* D-SACK 
  * 使用了 SACK 来告诉发送方，有哪些数据被重复接收了 
### 滑动窗口
* 无需等待确认应答，而可以继续发送数据的最大值。
* 窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除
* TCP 头里有一个字段叫 Window，也就是窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来
* 发送方的缓存
  * 已发送且收到ACK确认
  * 已发送未收到ACK确认
  * 未发送但总大小在接收方处理范围内
  * 未发送但总大小超过接收方处理范围
* 程序表示发送方四个部分
  * SND.WND：表示发送窗口的大小（大小是由接收方指定的）；
  * SND.UNA：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号
  * SND.NXT：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号
* 接收方的缓存
  * 已成功接收并确认的数据（等待应用进程读取）；
  * 未收到数据但可以接收的数据；
  * 未收到数据并不可以接收的数据  
* 程序表示接收方三个部分
  * RCV.WND：表示接收窗口的大小，它会通告给发送方。
  * RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号。
### 流量控制
TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制
* 窗口关闭
  * 在前面我们都看到了，TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。
  * 如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。
  * TCP 是如何解决窗口关闭时，潜在的死锁现象（窗口非 0 的 ACK 报文丢失）呢
    * TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。
    * 如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小 
* 糊涂窗口
窗口不断减少，并且发送的数据都是比较小的了，解决方法如下：
* 当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来
* 满足以下两个条件中的一条才可以发送数据：
  * 要等到窗口大小 >= MSS 或是 数据大小 >= MSS
  * 收到之前发送数据的 ack 回包
### 拥塞控制
在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大
* 拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的
  * 我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。
  * 拥塞窗口 cwnd 变化的规则：
    * 只要网络中没有出现拥塞，cwnd 就会增大；（发生了超时重传，就会认为网络出现了拥塞）
    * 但网络中出现了拥塞，cwnd 就减少；  
* 拥塞控制主要是四个算法：
  * 慢启动
    * 连接建立完成后，一开始初始化 cwnd = 1，表示可以传一个 MSS 大小的数据
    * 当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1
    * 可以看出慢启动算法，发包的个数是指数性的增长
    * 慢启动门限 ssthresh （slow start threshold）状态变量（一般65535）
      * 当 cwnd < ssthresh 时，使用慢启动算法。
      * 当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」  
  * 拥塞避免
    * 每当收到一个 ACK 时，cwnd 增加 1/cwnd
    * 线性增长
    * 当触发了重传机制，也就进入了「拥塞发生算法」 
  * 拥塞发生
    * 超时重传
      * ssthresh = cwnd / 2
      * cwnd = 1
    * 快速重传
      * cwnd = cwnd / 2
      * ssthresh = cwnd
      * 进入快速恢复算法
  * 快速恢复
    * 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
    * 重传丢失的数据包；
    * 如果再收到重复的 ACK，那么 cwnd 增加 1；
    * 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；
