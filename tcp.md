# study-up

# TCP
## 连接状态详解

CLOSED：初始状态

LISTEN：表示服务器端的某个SOCKET处于监听状态，可以接受连接

SYN_SENT：在服务器端监听后，客户端SOCKET执行CONNECT连接时，客户端发送SYN报文，此时客户端进入SYN_SENT状态，等待服务端的确认

SYN_RCVD：表示服务端接收到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态。

ESTABLISHED：表示连接已经建立

FIN_WAIT1：当SOCKET在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。

FIN_WAIT2：当对方回应ACK报文后，则进入到FIN_WAIT_2状态。

CLOSE_WAIT：表示正在等待关闭。但对方发送FIN报文给自己，你系统会回应一个ACK报文，此时进入CLOSE_WAIT状态。

LAST_ACK：被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。

TIME_WAIT：表示收到了对方的FIN报文，并发出了ACK报文，等2MSL后即可回到CLOSED状态。

## 问题

### 为什么TCP连接的时候是3次

因为要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。

如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。



### 为什么TCP连接的时候是3次，关闭的时候确是4次

因为只有客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发给客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端，我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文（所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来一次）。



### 为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接

这里同样要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL（报文最大生存时间），所以需要等这么长时间来确认服务端确实已经收到了。



### 如果已经建立了连接，但客户端突然出现故障了怎么办

TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若2小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没有反应，服务器就认为客户端出了故障，接着就关闭连接。



### TCP连接大量TIME_WAIT状态问题排查

#### TIME_WAIT产生原因

TIMEWAIT是主动关闭的一方，在使用四次挥手正常关闭TCP连接时产生的。

#### TIME_WAIT状态的必要性

1.确保两端能够完全关闭连接。如果被关闭方没有收到ACK，则会重发FIN，一来一去正好2MSL。

2.确保后续的连接不会收到脏数据。有足够的时间不让当前连接和后面的连接混在一起。

#### 大量TIME_WAIT出现场景

在高并发短连接的TCP服务器上，当服务器处理完请求后立即按照主动正常关闭连接这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端会显示连接不上。

#### 查看TCP连接数

```shell
netstat -ant|awk '/^tcp/ {S++[$NF]} END {for (a in S) print (a,S[a])}'
```

#### 如何尽量处理TIMEWAIT过多

编辑内核文件/etc/sysctl.conf

```shell
net.ipv4.tcp_syncookies = 1 #表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1 #表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 1 #表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
net.ipv4.tcp_fin_timeout #修改系默认的 TIMEOUT 时间
```

然后执行sysctl -p 让参数生效

简单来说，就是打开系统的TIMEWAIT重用和快速回收。

### http状态码
* 1**	信息，服务器收到请求，需要请求者继续执行操作
* 2**	成功，操作被成功接收并处理
* 3**	重定向，需要进一步的操作以完成请求
* 4**	客户端错误，请求包含语法错误或无法完成请求
* 5**	服务器错误，服务器在处理请求的过程中发生了错误

### 301 302
* 301	Moved Permanently	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
* 302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI

### 重传机制
* 超时重传
  * RTO（超时重传时间）略大于RTT（包往返时间）
* 快速重传 
  * 三次相同的ACK触发重传
* SACK 选择确认
  * 将接收数据缓存发送给发送方，告知哪些收到了哪些没收到，只重传没收到的
* D-SACK 
  * 使用了 SACK 来告诉发送方，有哪些数据被重复接收了 
### 滑动窗口
* 无需等待确认应答，而可以继续发送数据的最大值。
* 窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除
* TCP 头里有一个字段叫 Window，也就是窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来
* 发送方的缓存
  * 已发送且收到ACK确认
  * 已发送未收到ACK确认
  * 未发送但总大小在接收方处理范围内
  * 未发送但总大小超过接收方处理范围
* 程序表示发送方四个部分
  * SND.WND：表示发送窗口的大小（大小是由接收方指定的）；
  * SND.UNA：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号
  * SND.NXT：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号
* 接收方的缓存
  * 已成功接收并确认的数据（等待应用进程读取）；
  * 未收到数据但可以接收的数据；
  * 未收到数据并不可以接收的数据  
* 程序表示接收方三个部分
  * RCV.WND：表示接收窗口的大小，它会通告给发送方。
  * RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号。 
