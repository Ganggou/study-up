# study-up

# TCP
## 连接状态详解

CLOSED：初始状态

LISTEN：表示服务器端的某个SOCKET处于监听状态，可以接受连接

SYN_SENT：在服务器端监听后，客户端SOCKET执行CONNECT连接时，客户端发送SYN报文，此时客户端进入SYN_SENT状态，等待服务端的确认

SYN_RCVD：表示服务端接收到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态。

ESTABLISHED：表示连接已经建立

FIN_WAIT1：当SOCKET在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。

FIN_WAIT2：当对方回应ACK报文后，则进入到FIN_WAIT_2状态。

CLOSE_WAIT：表示正在等待关闭。但对方发送FIN报文给自己，你系统会回应一个ACK报文，此时进入CLOSE_WAIT状态。

LAST_ACK：被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。

TIME_WAIT：表示收到了对方的FIN报文，并发出了ACK报文，等2MSL后即可回到CLOSED状态。

## 问题

### 为什么TCP连接的时候是3次

因为要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。

如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。



### 为什么TCP连接的时候是3次，关闭的时候确是4次

因为只有客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发给客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端，我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文（所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来一次）。



### 为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接

这里同样要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL（报文最大生存时间），所以需要等这么长时间来确认服务端确实已经收到了。



### 如果已经建立了连接，但客户端突然出现故障了怎么办

TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若2小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没有反应，服务器就认为客户端出了故障，接着就关闭连接。



### TCP连接大量TIME_WAIT状态问题排查

#### TIME_WAIT产生原因

TIMEWAIT是主动关闭的一方，在使用四次挥手正常关闭TCP连接时产生的。

#### TIME_WAIT状态的必要性

1.确保两端能够完全关闭连接。如果被关闭方没有收到ACK，则会重发FIN，一来一去正好2MSL。

2.确保后续的连接不会收到脏数据。有足够的时间不让当前连接和后面的连接混在一起。

#### 大量TIME_WAIT出现场景

在高并发短连接的TCP服务器上，当服务器处理完请求后立即按照主动正常关闭连接这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端会显示连接不上。

#### 查看TCP连接数

```shell
netstat -ant|awk '/^tcp/ {S++[$NF]} END {for (a in S) print (a,S[a])}'
```

#### 如何尽量处理TIMEWAIT过多

编辑内核文件/etc/sysctl.conf

```shell
net.ipv4.tcp_syncookies = 1 #表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1 #表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 1 #表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
net.ipv4.tcp_fin_timeout #修改系默认的 TIMEOUT 时间
```

然后执行sysctl -p 让参数生效

简单来说，就是打开系统的TIMEWAIT重用和快速回收。

### http状态码
* 1**	信息，服务器收到请求，需要请求者继续执行操作
* 2**	成功，操作被成功接收并处理
* 3**	重定向，需要进一步的操作以完成请求
* 4**	客户端错误，请求包含语法错误或无法完成请求
* 5**	服务器错误，服务器在处理请求的过程中发生了错误

### 301 302
* 301	Moved Permanently	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
* 302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
