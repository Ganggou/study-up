## redis

#### redis单线程为什么这么快
redis基于reactor模式开发了文件事件处理器。采用IO多路复用同时监听多个socket，根据socket上的事件类型来选择对应的事件处理器来处理。
文件事件处理器包含 多个socket io多路复用程序 文件事件分派器 事件处理器
单线程快的原因：1.纯内存操作 2.核心是基于非阻塞的IO多路复用机制 3.单线程反而避免了多线程的频繁上下文切换带来的性能问题

#### redis持久化机制
### RDB redis database 将某个时刻的内存快照以二进制的方式写入磁盘
手动触发
* save命令，使redis处于阻塞状态
* bgsave命令，fork出一个子进程执行持久化，主进程只在fork过程中有短暂的阻塞，子进程save时，由于cow（copy on write）机制主进程中的写操作将操作在副本中
自动触发
* save m n:在m秒内，如果有n个键发生改变，则自动触发持久化，通过bgsave执行
* flushall：清空redis所有的数据库，flushdb清空当前redis所在库数据，会清空RDB文件，同时也会生成dump.rdb、内容为空
* 主从同步：全量同步会触发bgsave命令，生成rdb发送给从节点
优点
1.整个redis数据库将只包含一个文件dump.rdb 方便持久化
2.容灾性好，方便备份
3.性能最大化，fork子进程来完成写操作 让主进程继续处理命令
4.数据集大时 比AOF的启动效率更高
缺点
1.数据安全性低 RDB间隔一段时间进行持久化，数据有丢失风险
2.fork时占用cpu

### AOF append only file 以日志的形式记录服务器所处理的写、删除操作，以文本方式记录
1.所有的写命令会追加到AOF缓冲区
2.AOF缓冲区根据对应的策略向硬盘进行同步操作
3.随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的
4.当redis重启时可以加载AOF文件进行数据恢复
同步策略
* 每秒同步： 异步完成，宕机可能丢失一秒数据
* 每修改同步 同步持久化 最多丢一条
* 不同步，由操作系统控制
优点
1 数据安全
2 通过append模式写文件 即使中途宕机也不会破坏已存在的内容 redis-check-aof工具解决数据一致性问题
3 AOF机制的rewrite模式 定期对AOF文件进行重写以达到压缩的目的
缺点
1 AOF文件比RDB文件大，恢复速度慢
2 比rdb启动效率低
3 运行效率没rdb高

AOF文件比RDB更新频率高 优先使用AOF还原数据
AOF比RDB更安全也更大
RDB性能比AOF好
优先加载AOF

#### redis的过期键的删除策略
* 惰性过期 只有访问到一个key时，才会判断key是否过期，对cpu友好对内存不友好
* 定期过期 每隔一段时间扫描一定数量的key清除过期的

#### redis分布式锁底层实现
* 首先利用setnx来保证 如果key不存在才能获取到锁 如果key存在则获取不到
* 利用lua脚本来保证多个redis操作的原子性
* 考虑到锁过期 需要额外的一个看门狗定时任务来监听锁是否需要续约
* 考虑到redis节点挂掉 需要采用红锁方式来同时向N/2 + 1个系欸但申请锁，都申请到了才能证明获取锁成功

#### redis和mysql如何保证数据一致
* 先更新mysql再更新redis 如果更新redis失败 可能仍然不一致
* 先删除redis缓存数据 在更新mysql
* 延时双删 先删除redis缓存数据，再更新mysql，延迟几百毫秒再删除redis缓存，这样就算更新mysql时有其他线程读了mysql，把老数据读到了redis中也会被删除

#### redis集群方案
### 主从模式
主库读写和从库进行数据同步，节点宕机后客户端需要手动修改ip

### 哨兵模式
* 集群监控 负责监控redis master 和slave进程是否正常工作
* 消息通知 某个redis实例有故障，通知管理员
* 故障转移 master node 挂掉了会转移到slave node上
* 配置中心 如果故障转移发生了，通知client客户端新的master地址

* 故障转移时 判断一个master node是否宕机需要大部分哨兵同意，涉及到分布式选举
* 即使部分哨兵节点挂掉了 哨兵集群仍能工作
* 哨兵通常需要三个实例
* 哨兵+redis主从部署框架不保证数据零丢失，只能保证redis集群的可靠性

### redis cluster  属于服务端分片技术，利用槽的概念一共分成16384个槽
* 通过哈希的方式将数据分片每个节点均分存储一定哈希槽区间的数据
* 每份数据分片会存储在多个互为主从的多节点上
* 数据写入先写主节点再同步到从节点
* 同一分片多个节点间的数据不保持强一致性
* 读取数据时 当客户端操作的key没有分配在该节点上时 redis会返回转向指令 指向正确的节点
* 扩容时需要把旧节点的数据迁移一部分到新结点

*每个redis开放两个端口
优点
* 无中心架构
* 哨兵监控 故障转移
* 客户端连接集群中任一节点即可
* 高性能
缺点
* 运维复杂
* 只能使用0号数据库
* 不支持批量操作
* 分布式逻辑和存储模块耦合

### redis sharding 客户端分片
优点
*简单，节点相互独立 容易线性扩展
缺点
* 不支持动态增删节点
* 连接不能共享

#### redis 如何配置key的过期时间，原理
redis设置key的过期时间 1、EXPIRE 2 SETEX
实现原理 定期过期和惰性过期结合 惰性过期平衡执行频率和执行时长，定期删除遍历每个database（默认16个）检查当前库中指定个数的key（默认20个）程序中有一个全局变量记录查到哪个数据库


#### redis有哪些数据结构，分别的应用场景
* 字符串 
* 哈希表 key-value对
* 列表 栈 队列
* 集合 存储多个元素 但不能重复
* 有序集合  排行榜

#### redis主从复制的核心原理
通过执行slaveof命令或设置slaveof选项让一个服务器去复制另一个服务器的数据，主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从服务器，从服务器一般只读
全量复制
* 主节点通过bgsave命令fork子进程进行RDB持久化，该过程非常消耗CPU、内存、硬盘IO
* 主节点通过网络将RDB文件发送给从节点，对主从节点的带宽带来很大的消耗
* 从节点清空老数据 载入新RDB文件的过程是阻塞的 无法响应客户端命令
部分复制 增量复制
* 复制偏移量 执行复制的双方主从节点分别会维护一个复制偏移量offset 以主节点的偏移量为主
* 复制挤压缓冲区 主节点内部围护一个固定长度、先进先出的队列作为复制挤压缓冲区 当主从节点offset的差距过大超过缓冲区长度 将无法部分复制 只能执行全量复制
* 服务器运行ID，从节点redis断开重连的时候 根据运行ID来判断同步的进度
	* 如果从节点保存的runid与主节点现在的runid相同，说明从节点之前同步过，主节点会继续尝试部分复制
	* 如果从节点保存的runid不同，只能进行全量复制

#### 布隆过滤器原理，优缺点
* 位图 添加数据时将数据进行hash 对应到bit位，将该bit改为1，hash函数可以是多个，多个可以减少碰撞概率
优点
* 占内存小
* 增加和查询元素的时间复杂度为O(n) n为hash函数的个数
* hash函数相互之间没有关系，方便并行运算
* 布隆过滤器不需要存储元素本身，保密
* 数量很大时，布隆过滤器可以表示全集
* 使用同一组数列函数的布隆过滤器可以进行交 并 差运算
缺点
* 误判率
* 不能获取元素本身
* 一般情况下不能从布隆过滤器中删除元素

#### 常见缓存淘汰算法
* FIFO                
* LRU 最近最少使用 根据最近被使用的时间
* LFU 最不经常使用 在一段时间内 被使用的次数

#### 分布式系统常用的缓存方案
* 客户端缓存： 页面和浏览器缓存 app缓存 h5缓存 localStorage
* CDN缓存： 内容存储：数据的缓存 内容分发： 负载均衡
* nginx缓存： 静态资源
* 服务器缓存： 本地缓存，外地缓存
* 数据库缓存：持久层缓存，mysql查询缓存
* 操作系统缓存：page cache、buffer cache

#### 缓存穿透 缓存击穿 缓存雪崩
### 缓存穿透 缓存中查不到 数据库中也查不到
解决方案：
* 对参数进行合法性校验
* 数据库中没查到的结果也存到缓存中（过期时间设短一点 以防止redis key被过多占用）
* 添加过滤器 布隆过滤器 在访问redis前判断数据是否存在
### 缓存击穿 缓存中没有 数据库中有，一般出现在缓存数据初始化或者key过期，写入缓存需要一定时间，高并发时，db向redis写，db压力大
解决方案：
* 设置不会过期的热点缓存，定期重建缓存
* 加载db的时候，防止并发 db往redis写的时候加锁
### 缓存雪崩 缓存大面积过期 请求转发到DB
解决方案：
* 把缓存的失效时间分散开，例如在原有失效时间基础上增加一个随机值
* 对热点数据设置永不过期

#### redis事务
### 事务开始
MULTI命令执行 标识着一个事务的开始，MULTI命令会去将客户端的flags属性中打开REDIS_MULTI标识来完成
### 命令入队
当客户端切换到事务状态后，如果客户端发送MULTI、EXEC、WATCH、DISCARD中的一个，立即执行此命令，否则将命令放入一个事务队列里，然后向客户端返回QUEUED回复（FIFO）
### 事务执行
客户端发送EXEC命令 服务器执行EXEC命令逻辑
* 如果客户端状态的flags属性不包含REDIS_MULTI标识或者包含REDIS_DIRTY_CAS或者REDIS_DIRTY_EXEC标识，事务就取消

