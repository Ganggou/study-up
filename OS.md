## OS
* 进程与线程
  * 进程是资源分配的最小单位 
  * 线程是程序执行中的最小单元，线程能够共享进程的大部分资源，并参与CPU的调度
  * 进程与线程的差别
    * 进程是CPU资源分配的基本单位，线程是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。
    * 进程拥有自己的资源空间，一个进程包含若干个线程，线程与CPU资源分配无关，多个线程共享同一进程内的资源。
    * 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；
    * 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；
    * 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮
* 同一进程中的线程可以共享哪些数据？
  * 进程代码段
  * 进程的公有数据（全局变量、静态变量...）
  * 进程打开的文件描述符
  * 进程的当前目录
  * 信号处理器/信号处理函数：对收到的信号的处理方式
  * 进程ID与进程组ID
* 线程独占哪些资源？
  * 线程ID
  * 一组寄存器的值
  * 线程自身的栈（堆是共享的）
  * 错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；
  * 信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）
* 进程间通信有哪些方式
  * 管道/匿名管道(pipe)
    * 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。
    * 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);
    * 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。
    * 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。管道的实质是一个内核缓冲区
    * 局限
      * 只支持单向数据流；
      * 只能用于具有亲缘关系的进程之间，没有名字；
      * 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；
      * 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；
  * 有名管道
    * 不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。
    * 值的注意的是，有名管道严格遵循先进先出,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。
    * 有名管道的名字存在于文件系统中，内容存放在内存中
  * 信号
    * 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
    * 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。
    * 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。
    * 信号来源
      * 信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：
        * 硬件来源：用户按键输入Ctrl+C退出、硬件异常如无效的存储访问等。
        * 软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号
    * 信号生命周期和处理流程
    （1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；
    （2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。
    （3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。
  * 消息队列
    * 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
    * 与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
    * 另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达
    * 消息队列允许一个或多个进程向它写入与读取消息.
    * 管道和消息队列的通信数据都是先进先出的原则。
    * 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。
    * 消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。
  * 共享内存(share memory)
    * 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。
    * 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。
    * 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。
  * 信号量
    * 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。
    * 为了获得共享资源，进程需要执行下列操作：
      * 创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。
      * 等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。
      * 挂出一个信号量：该操作将信号量的值加1，也称为V操作。
    * 信号量与互斥量之间的区别
      * 互斥量用于线程的互斥，信号量用于线程的同步
      * 互斥量值只能为0/1，信号量值可以为非负整数
      * 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。
  * 套接字(socket）
    * 这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信
* 死锁必要条件
  * 互斥
  * 占有并等待
  * 非抢占
  * 循环等待    
* 进程有哪几种状态？
  * 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；
  * 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；
  * 阻塞状态： 进程等待某种条件，在条件满足之前无法执行；
  * 状态转换
    * 就绪->执行， 当前运行进程阻塞，调度程序选一个优先权最高的进程占有处理机；
    * 执行->就绪， 当前运行进程时间片用完；
    * 执行->阻塞，当前运行进程等待键盘输入，进入了睡眠状态。
    * 阻塞->就绪，I/O操作完成，被中断处理程序唤醒。
* 分页和分段有什么区别
  * 目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；
  * 大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；
  * 地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；
  * 信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；
  * 内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。
* 操作系统中进程调度策略有哪几种
  * FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU
  * SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度
  * 优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化
  * 时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。
  * 多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。
  * 多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。
* 线程同步的方式
  * 互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
  * 信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
  * 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作
* 虚拟内存
  * 每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存 
* 页面置换算法
  * FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；
  * LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；
  * LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；
  * OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法
* 颠簸
  * 颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。
  * 内存颠簸的解决策略包括：
    * 如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；
    * 如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；
    * 否则，还剩下两个办法：终止该进程或增加物理内存容量。
* 什么是用户态和内核态？
为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。
  * 用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取；
  * 内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。
* 如何从用户态切换到内核态？
  * 系统调用：比如读取命令行输入。本质上还是通过中断实现
  * 用户程序发生异常时：比如缺页异常
  * 外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序
* 协程
  * 用户态轻量级线程 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈
  * 协程的好处
    * 无需线程上下文切换的开销
    * 无需原子操作锁定及同步的开销
    * 方便切换控制流，简化编程模型
  * 协程的缺点
    * 无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。
    * 进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序
