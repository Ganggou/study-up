## mysql

### 索引
索引是一种数据结构，可以帮助我们快速的进行数据的查找，索引的数据结构和具体存储引擎的实现有关，在 MySQL 中使用较多的索引有 Hash 索引，B+ 树索引等，而我们经常使用的 InnoDB 存储引擎的默认索引实现为：B+ 树索引
* 为什么使用索引
  * 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
  * 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
  * 帮助服务器避免排序和临时表。
  * 将随机IO变为顺序IO。
  * 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义
* Innodb为什么要用自增id作为主键
  * 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE（optimize table）来重建表并优化填充页面
* Hash 索引和 B+ 树索引有什么区别或者说优劣呢
hash 索引底层就是 hash 表，进行查找时，调用一次 hash 函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+ 树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。
  * hash 索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。
  * 因为在 hash 索引中经过 hash 函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而 B+ 树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。
  * hash 索引不支持使用索引进行排序，原理同上。
  * hash 索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为 hash 函数的不可预测。
  * hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询
  * hash 索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生 hash 碰撞，此时效率可能极差。而 B+ 树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。
* 什么是聚簇索引
  * 聚簇索引就是按照每张表的 主键 构造一棵B+树，同时叶子节点中存放的就是整张表的行记录数据。在 InnoDB 中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则MySQL自动为InnoDB表生成一个隐含字段来建立聚簇索引，这个字段长度为6个字节，类型为长整形。当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。
* 索引的底层实现
  * hash索引  
    * 基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。
  * B-Tree索引（MySQL使用B+Tree）
    * B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。
  * B+Tree索引
    * 是B-Tree的改进版本，同时也是数据库索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。
    * n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。
    * 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
    * 所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。
    * B+ 树中，数据对象的插入和删除仅在叶节点上进行。
    * B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。
* 索引有哪些优缺点
  * 索引的优点
    * 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
    * 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 
  * 索引的缺点
    * 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率
    * 空间方面：索引需要占物理空间。
* 聚簇索引和非聚簇索引的区别
  * 聚簇索引的叶子节点存放的是主键值和数据行，支持覆盖索引
  * 非聚簇索引的叶子节点存放的是主键值或数据记录的地址（InnoDB辅助索引的data域存储相应记录主键的值，MyISAM辅助索引的data域保存数据记录的地址
* MyISAM和InnoDB实现B+树索引方式的区别是什么
  * MyISAM，B+Tree叶节点的data域存放的是数据记录的地址，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引”
  * InnoDB，其数据文件本身就是索引文件，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为“聚簇索引”或者聚集索引，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方
* MySQL中有几种索引类型
  * FULLTEXT ：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。
  * HASH ：由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。
  * BTREE ：BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。
* 覆盖索引是什么
  * 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称 之为“覆盖索引”   
* 联合索引是什么?为什么需要注意联合索引中的顺序
  * MySQL 可以使用多个字段同时建立一个索引，叫做联合索引。
  * 在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引
  * MySQL 使用索引时需要索引有序，假设现在建立了"name,age,school"的联合索引，那么索引的排序为：先按照name排序，如果 name 相同，则按照 age 排序，如果 age 的值也相等，则按照 school 进行排序。当进行查询时，此时索引仅仅按照 name 严格有序，因此必须首先使用 name 字段进行等值查询，之后对于匹配到的列而言，其按照 age 字段严格有序，此时可以使用 age 字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整
* 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因
  * MySQL 提供了 explain 命令来查看语句的执行计划，MySQL 在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引
  * possilbe_key 此语句可能会使用的索引
  * key 此语句实际使用的索引
  * key_len 使用的索引长度
* 那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢
  * 使用不等于查询
  * 列参与了数学运算或者函数
  * 当 mysql 分析全表扫描比使用索引快的时候不使用索引。
  * 当使用联合索引，前面一个条件为范围查询，后面的即使符合最左前缀原则，也无法使用索引。 
* 为什么Mysql用B+树做索引而不用B-树或红黑树、二叉树
  * B-Tree
    * B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B(B-)树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了
    * 由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引
 * 二叉树
   * 树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高
 * 红黑树
   * 树的高度随着数据量增加而增加，IO代价高
* MySQL索引种类
  * 普通索引
  * 唯一索引(主键索引、唯一索引)
  * 联合索引
  * 全文索引
  * 空间索引  
* 索引在什么情况下遵循最左前缀的规则
  * 在建立了联合索引的前提条件下，数据库会一直从左向右的顺序依次查找，直到遇到了范围查询(>,<,between,like等) 

### 事务
* 什么是事务
  * 事务是一系列的数据库操作，他们要符合 ACID 特性，事务是数据库应用的基本单位。MySQL 事务主要用于处理操作量大，复杂度高的数据 
* ACID特性
  * A=Atomicity：原子性，就是要么全部成功，要么全部失败。不可能只执行一部分操作。
  * C=Consistency：一致性，系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态，不会存在中间状态。
  * I=Isolation：隔离性，通常来说：一个事务在完全提交之前，对其他事务是不可见的.注意前面的通常来说加了红色，意味着有例外情况。
  * D=Durability：持久性，一旦事务提交，那么就永远是这样子了，哪怕系统崩溃也不会影响到这个事务的结果
* MySQL中为什么要有事务回滚机制
  * 而在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。当事务已经被提交之后，就无法再次回滚了
  * 回滚日志作用
    * 能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息
    * 在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因
* 数据库并发事务会带来哪些问题
  * 脏读：A 事务读取到了 B 事务未提交的内容，但是之后B事务满足一致性等特性而做了回滚操作，那么读取事务得到的结果就是脏数据了。
  * 幻读：A 事务读取了一个范围的内容，而同时 B 事务在此期间插入（删除）了一条数据。造成"幻觉"
  * 丢弃修改：两个写事务T1 T2同时对A=0进行递增操作，结果T2覆盖T1，导致最终结果是1 而不是2，事务被覆盖
  * 不可重复读：当设置T2事务只能读取 T1 事务已经提交的部分，T2 读取一个数据，然后T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同
* 怎么解决这些问题呢?MySQL 的事务隔离级别了解吗
  * 未提交读(READ UNCOMMITTED)：事务中发生了修改，即使没有提交，其他事务也是可见的，比如对于一个数A原来50修改为100，但是我还没有提交修改，另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候A还是50，但是另一个事务看到的A是100.可能会导致脏读、幻读或不可重复读
  * 已提交读(READ COMMITTED)：对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的，举例就是对于一个数A原来是50，然后提交修改成100，这个时候另一个事务在A提交修改之前，读取的A是50，刚读取完，A就被修改成100，这个时候另一个事务再进行读取发现A就突然变成100了；可以阻止脏读，但是幻读或不可重复读仍有可能发生
  * 可重复读(REPEATABLE READ)：就是对一个记录读取多次的记录是相同的，比如对于一个数A读取的话一直是A，前后两次读取的A是一致的；可以阻止脏读和不可重复读，但幻读仍有可能发生
  * 可串行化(SERIALIZABLE)：在并发情况下，和串行化的读取的结果是一致的，没有什么不同，比如不会发生脏读和幻读；该级别可以防止脏读、不可重复读以及幻读
* Innodb使用的是哪种隔离级别呢
  * MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重复读），与 SQL 标准不同的地方在于InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别 下使用的是 Next-Key Lock 锁算法 ，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以 说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别。InnoDB 存储引擎在分布式事务 的情况下一般会用到SERIALIZABLE(可串行化)隔离级别
* 不可重复读和幻读区别是什么
  * 不可重复读的重点是修改，同样的条件, 你读取过的数据, 再次读取出来发现值不一样了
  * 幻读的重点在于新增或者删除，同样的条件, 第1次和第2次读出来的记录数不一样

### 锁相关
当数据库有并发事务的时候,可能会产生数据的不一致,这时候需要一些机制来保证访问的次序.
* 按照锁的粒度划分可以分成
  * 行锁
    * 描述：行级锁是mysql中锁定粒度最细的一种锁。表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁
    * 特点：开销大，加锁慢，会出现死锁。发生锁冲突的概率最低，并发度也最高
  * 表锁
    * 描述：表级锁是mysql中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分mysql引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）
    * 特点： 开销小，加锁快，不会出现死锁。发生锁冲突的概率最高，并发度也最低
  * 页锁
    * 描述：页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定相邻的一组记录。BDB 支持页级锁。
    * 特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 
* 按照使用的方式划分可以分为
  * 共享锁
    * 描述：
      共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。
      如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。
    * 用法：
      SELECT … LOCK IN SHARE MODE;
      在查询语句后面增加LOCK IN SHARE MODE，MySQL 就会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据
  * 排它锁
    * 描述：
      排他锁又称写锁、独占锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。
    * 用法：
      SELECT … FOR UPDATE;
      在查询语句后面增加FOR UPDATE，MySQL 就会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。
* 按照思想的划分
  * 乐观锁
    * 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读的问题。乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。
  * 悲观锁
    * 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
* MySQL常用存储引擎的锁机制
  * MyISAM和MEMORY采用表级锁(table-level locking)
  * BDB采用页面锁(page-level locking)或表级锁，默认为页面锁
  * InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁
* InnoDB 存储引擎有几种锁算法
  * Record Lock — 单个行记录上的锁；
  * Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；
  * Next-Key Lock — 锁定一个范围，包括记录本身 
* 死锁
  * 是指二个或者二个以上的进程在执行时候，因为争夺资源造成相互等待的现象，进程一直处于等待中，无法得到释放，这种状态就叫做死锁 
  * 案例
    * 批量入库，存在则更新，不存在则插入
    * 对不存在的行进行锁时会有gap锁
    * 锁住范围（无限小或小于锁住值的最大值， 无限大或者大于锁住值的最小值）
    * insert into tab(xx,xx) on duplicate key update xx=‘xx’ 
* 如何处理死锁
  * 通过innodblockwait_timeout来设置超时时间，一直等待直到超时
  * 发起死锁检测，发现死锁之后，主动回滚死锁中的事务，不需要其他事务
* 如何避免死锁
  * 为了在单个innodb表上执行多个并发写入操作时避免死锁，可以在事务开始时，通过为预期要修改行，使用select …for update语句来获取必要的锁，即使这些行的更改语句是在之后才执行的
  * 在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时在申请排他锁。因为这时候当用户在申请排他锁时，其他事务可能又已经获得了相同记录的共享锁
  * 如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发获取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会
  * 改变事务隔离级别
* 如何开启死锁检测
  * 设置innodbdeadlockdetect设置为on可以主动检测死锁，在innodb中这个值默认就是on开启的状态 
