## GC
* 根对象
  * 全局变量
  * 执行栈
  * 寄存器
* 常见GC方式
  * 追踪式 (go java js)
    * 标记清扫 从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象，标记清扫算法分为两阶段：标记阶段和清扫阶段（go）
    * 标记整理 为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内存上
    * 增量式 将标记与清扫的过程分批执行，每次执行很小的部分，从而增量的推进垃圾回收，达到近似实时、几乎无停顿的目的
    * 增量整理 在增量式的基础上，增加对对象的整理过程
    * 分代式 将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收
  * 计数式 (python)

* 标记清理的问题
  * STW，stop the world；让程序暂停，程序出现卡顿。
  * 标记需要扫描整个heap
  * 清除数据会产生heap碎片
* 三色并发标记法
  * 首先：程序创建的对象都标记为白色
  * gc开始：扫描所有可到达的对象，标记为灰色
  * 从灰色对象中找到其引用对象标记为灰色，把灰色对象本身标记为黑色
  * 监视对象中的内存修改，并持续上一步的操作，直到灰色标记的对象不存在
  * 此时，gc回收白色对象。
  * 最后，将所有黑色对象变为白色，并重复以上所有过程。
* 屏障技术
  * 内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作。 
* 想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：
  * 强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；
  * 弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径；
* 插入写屏障
  * 插入写屏障是一种相对保守的屏障技术，它会将有存活可能的对象都标记成灰色以满足强三色不变性
* 删除写屏障
  * 老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用
* 增量与并发垃圾收集
  * 增量垃圾收集 — 增量地标记和清除垃圾，降低应用程序暂停的最长时间；
  * 并发垃圾收集 — 利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；
  * 因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要使用屏障技术保证垃圾收集的正确性；与此同时，应用程序也不能等到内存溢出时触发垃圾收集，因为当内存不足时，应用程序已经无法分配内存，这与直接暂停程序没有什么区别，增量和并发的垃圾收集需要提前触发并在内存不足前完成整个循环，避免程序的长时间暂停    
